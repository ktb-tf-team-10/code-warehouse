import os
import io
import time
import base64
import requests
import boto3
from typing import Optional
from fastapi import FastAPI, BackgroundTasks
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from google import genai
from google.genai import types
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
import uvicorn
from dotenv import load_dotenv

# env variables 
load_dotenv()

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
NANO_BANANA_DIR = os.path.join(BASE_DIR, "nano_banana_3d")
os.makedirs(NANO_BANANA_DIR, exist_ok=True)

GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY")
if not GOOGLE_API_KEY:
    raise RuntimeError("GOOGLE_API_KEY not found in environment variables.")
MESHY_API_KEY = os.environ.get("MESHY_API_KEY")
if not MESHY_API_KEY:
    raise RuntimeError("MESHY_API_KEY not found in environment variables.")
S3_BUCKET = os.environ.get("S3_BUCKET")
if not S3_BUCKET:
    raise RuntimeError("S3_BUCKET not found in environment variables.")
S3_REGION = os.environ.get("S3_REGION", "ap-northeast-2")
if not S3_REGION:
    raise RuntimeError("S3_REGION not found in environment variables.")
SPRING_CALLBACK_URL = os.environ.get("SPRING_CALLBACK_URL")
if not SPRING_CALLBACK_URL:
    raise RuntimeError("SPRING_CALLBACK_URL not found in environment variables.")

MESHY_BASE = "https://api.meshy.ai/v1"
CLOUD_FRONT_DOMAIN = "https://dns7warjxrmv9.cloudfront.net"

try:
    with open(os.path.join(NANO_BANANA_DIR, "prompt_main.md"), "r") as f:
        PROMPT_TEXT = f.read()
except FileNotFoundError:
    raise RuntimeError("Prompt file 'prompt_main.md' not found in nano_banana_3d directory.")

# client initialization
s3_client = boto3.client("s3", region_name=S3_REGION)
app = FastAPI()

# dto
class GenerateRequest(BaseModel):
    task_id: str  # Spring에서 생성해서 전달
    image_url1: str
    image_url2: Optional[str] = None
    image_url3: Optional[str] = None


# --- 유틸리티: Spring 상태 업데이트 ---
def notify_spring(job_id: str, step: int, step_name: str, progress: int, model_url: str = None, error: str = None):
    """Spring에 현재 상태 업데이트"""
    payload = {
        "jobId": job_id,
        "step": step,
        "step_name": step_name,
        "progress": progress,
    }
    if model_url:
        payload["model_url"] = model_url
    if error:
        payload["error"] = error

    try:
        requests.post(f"{SPRING_CALLBACK_URL}/api/internal/invitations/progress", json=payload, timeout=10)
    except Exception as e:
        print(f"Failed to notify Spring: {e}")


# --- 유틸리티: bytes -> data URI 변환 ---
def bytes_to_data_uri(image_bytes: bytes, mime_type: str) -> str:
    """이미지 bytes를 Meshy가 요구하는 data URI로 변환"""
    b64 = base64.b64encode(image_bytes).decode("utf-8")
    return f"data:{mime_type};base64,{b64}"

# --- 통합 API: 이미지 생성 + 3D 모델 생성 ---
@app.post("/api/generate")
async def generate(request: GenerateRequest, background_tasks: BackgroundTasks):
    """
    이미지 생성 + 3D 모델 생성을 하나의 API로 처리합니다.
    즉시 응답하고 백그라운드에서 작업을 진행합니다.
    """
    background_tasks.add_task(
        process_pipeline,
        request.task_id,
        request.image_url1,
        request.image_url2,
        request.image_url3
    )
    return JSONResponse({"status": "processing", "task_id": request.task_id})


def process_pipeline(task_id: str, image_url1: str, image_url2: str = None, image_url3: str = None):
    """백그라운드에서 전체 파이프라인 실행"""
    try:
        # === 1단계: 이미지 생성 (0~30%) ===
        print(f"[{task_id}] 1단계: 이미지 생성 시작 (15%)")
        notify_spring(task_id, step=1, step_name="GENERATING_IMAGE", progress=15)

        client = genai.Client(api_key=GOOGLE_API_KEY)
        contents = [PROMPT_TEXT]
        contents.append("\n\n[Image 1]:")
        contents.append(download_image_as_part(image_url1))

        if image_url2:
            contents.append("\n\n[Image 2]:")
            contents.append(download_image_as_part(image_url2))

        if image_url3:
            contents.append("\n\n[Image 3]:")
            contents.append(download_image_as_part(image_url3))

        response = client.models.generate_content(
            model="gemini-3-pro-image-preview",
            contents=contents,
            config=types.GenerateContentConfig(
                response_modalities=['TEXT', 'IMAGE'],
                image_config=types.ImageConfig(
                    aspect_ratio="1:1",
                    image_size="2K"
                ),
            )
        )

        generated_image = None
        for part in response.parts:
            if part.as_image():
                generated_image = part.as_image()
                break

        if not generated_image:
            raise Exception("No image generated by Gemini")

        print(f"[{task_id}] 1단계: 이미지 생성 완료")

        # === 2단계: 3D 모델 생성 (30~100%) ===
        print(f"[{task_id}] 2단계: 3D 모델 생성 시작 (30%)")
        notify_spring(task_id, step=2, step_name="GENERATING_3D", progress=30)

        # 이미지를 data URI로 변환
        mime_type = generated_image.mime_type or "image/png"
        data_uri = bytes_to_data_uri(generated_image.image_bytes, mime_type)

        # Meshy API 호출
        session = get_meshy_session()
        headers = {"Authorization": f"Bearer {MESHY_API_KEY}"}
        payload = {
            "image_url": data_uri,
            "ai_model": "latest",
            "should_texture": True,
            "enable_pbr": False,
            "should_remesh": True,
            "topology": "triangle",
            "target_polycount": 100000,
            "symmetry_mode": "auto",
        }

        meshy_response = session.post(f"{MESHY_BASE}/image-to-3d", headers=headers, json=payload, timeout=60)
        meshy_response.raise_for_status()
        meshy_task_id = meshy_response.json().get("result")

        # Meshy 폴링
        while True:
            status_response = session.get(f"{MESHY_BASE}/image-to-3d/{meshy_task_id}", headers=headers, timeout=30)
            status_response.raise_for_status()
            status_data = status_response.json()

            meshy_status = status_data.get("status")
            meshy_progress = status_data.get("progress", 0)

            # 전체 진행률 계산 (30 + meshy_progress * 0.7)
            total_progress = 30 + int(meshy_progress * 0.7)
            print(f"[{task_id}] 2단계: 3D 모델 생성 중... ({total_progress}%)")
            notify_spring(task_id, step=2, step_name="GENERATING_3D", progress=total_progress)

            if meshy_status == "SUCCEEDED":
                break
            elif meshy_status == "FAILED":
                raise Exception("Meshy 3D generation failed")

            time.sleep(5)

        # 3D 모델 URL 가져오기
        model_url = status_data.get("model_urls", {}).get("glb")
        if not model_url:
            raise Exception("No GLB model URL returned from Meshy")

        # === 3단계: S3에 3D 모델 저장 ===
        model_response = requests.get(model_url, timeout=60)
        model_response.raise_for_status()

        timestamp = int(time.time())
        filename = f"3d_models/{task_id}_{timestamp}.glb"

        buffer = io.BytesIO(model_response.content)
        s3_client.upload_fileobj(
            buffer,
            S3_BUCKET,
            filename,
            ExtraArgs={"ContentType": "model/gltf-binary"}
        )

        s3_model_url = f"{CLOUD_FRONT_DOMAIN}/{filename}"

        # 완료 알림
        print(f"[{task_id}] 완료! (100%) - {s3_model_url}")
        notify_spring(task_id, step=2, step_name="COMPLETE", progress=100, model_url=s3_model_url)

    except Exception as e:
        print(f"[{task_id}] 실패: {e}")
        notify_spring(task_id, step=0, step_name="FAILED", progress=0, error=str(e))

# --- 3. 유틸리티: Meshy API 통신 세션 (SSL 에러 방지용) ---
def get_meshy_session():
    """
    Meshy API와의 통신을 위한 requests.Session 객체를 생성합니다.
    SSL 연결 오류(SSLEOFError)나 일시적인 네트워크 오류에 대비하여
    재시도(Retry) 로직과 HTTPAdapter를 설정합니다.
    """
    session = requests.Session()
    # 재시도 전략 설정: 최대 5회, 백오프(대기시간) 적용, 특정 에러 코드(5xx) 및 429(Rate Limit) 대응
    retries = Retry(
        total=5,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["HEAD", "GET", "POST"]
    )
    adapter = HTTPAdapter(max_retries=retries)
    # http:// 및 https:// 요청 모두에 어댑터 적용
    session.mount("https://", adapter)
    session.mount("http://", adapter)
    return session

# --- 유틸리티: URL에서 이미지 다운로드 후 Gemini Part로 변환 ---
def download_image_as_part(url: str) -> types.Part:
    """URL에서 이미지 다운로드 후 Gemini Part로 반환"""
    response = requests.get(url, timeout=30)
    response.raise_for_status()

    content_type = response.headers.get("Content-Type", "image/png")
    if ";" in content_type:
        content_type = content_type.split(";")[0]

    return types.Part.from_bytes(data=response.content, mime_type=content_type)


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
