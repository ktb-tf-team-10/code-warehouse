import os
import io
import time
import base64
import requests
import mimetypes
import boto3
from typing import Optional
from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from google import genai
from google.genai import types
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
import uvicorn
from dotenv import load_dotenv

# env variables 
load_dotenv()

NANO_BANANA_DIR = "nano_banana_3d"
os.makedirs(NANO_BANANA_DIR, exist_ok=True)

GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY")
if not GOOGLE_API_KEY:
    raise RuntimeError("GOOGLE_API_KEY not found in environment variables.")
MESHY_API_KEY = os.environ.get("MESHY_API_KEY")
if not MESHY_API_KEY:
    raise RuntimeError("MESHY_API_KEY not found in environment variables.")
S3_BUCKET = os.environ.get("S3_BUCKET")
if not S3_BUCKET:
    raise RuntimeError("S3_BUCKET not found in environment variables.")
S3_REGION = os.environ.get("S3_REGION", "ap-northeast-2")
if not S3_REGION:
    raise RuntimeError("S3_REGION not found in environment variables.")

MESHY_BASE = "https://api.meshy.ai/v1"
CLOUD_FRONT_DOMAIN = "https://dns7warjxrmv9.cloudfront.net"

try:
    with open(os.path.join(NANO_BANANA_DIR, "prompt_main.md"), "r") as f:
        PROMPT_TEXT = f.read()
except FileNotFoundError:
    raise RuntimeError("Prompt file 'prompt_main.md' not found in nano_banana_3d directory.")

# client initialization
s3_client = boto3.client("s3", region_name=S3_REGION)
app = FastAPI()

# dto
class NanoRequest(BaseModel):
    image_url1: str
    image_url2: Optional[str] = None
    image_url3: Optional[str] = None
    # task_id: str

@app.post("/api/generate-nano")
async def generate_nano(request: NanoRequest):
    try:
        # Gemini 클라이언트 초기화
        client = genai.Client(api_key=GOOGLE_API_KEY)

        # URL에서 이미지 다운로드 후 Gemini에 전달
        contents = [PROMPT_TEXT]
        contents.append("\n\n[Image 1]:")
        contents.append(download_image_as_part(request.image_url1))

        if request.image_url2:
            contents.append("\n\n[Image 2]:")
            contents.append(download_image_as_part(request.image_url2))

        if request.image_url3:
            contents.append("\n\n[Image 3]:")
            contents.append(download_image_as_part(request.image_url3))
        
        # 4) Gemini 모델 호출하여 이미지 생성
        # gemini-3-pro-image-preview 모델을 사용하며, 1:1 비율 / 2K 해상도를 요청합니다.
        response = client.models.generate_content(
            model="gemini-3-pro-image-preview",
            contents=contents,
            config=types.GenerateContentConfig(
                response_modalities=['TEXT', 'IMAGE'], # 텍스트와 이미지를 모두 반환받을 수 있도록 설정
                image_config=types.ImageConfig(
                    aspect_ratio="1:1",
                    image_size="2K"
                ),
            )
        )
        
        # 5) 생성된 이미지 추출
        generated_image = None
        for part in response.parts:
            if part.as_image():
                generated_image = part.as_image()
                break
        
        if not generated_image:
            if response.text:
                raise HTTPException(status_code=500, detail=f"Gemini returned text instead of image: {response.text}")
            raise HTTPException(status_code=500, detail="No image generated by Gemini.")

        # 이미지 확인 (개발용 - 배포 시 제거)
        generated_image.show()

        # 6) S3에 업로드
        timestamp = int(time.time())
        mime_type = generated_image.mime_type or "image/png"
        ext = "jpg" if "jpeg" in mime_type else "png"
        filename = f"nano_banana/{timestamp}.{ext}"

        # Gemini 이미지에서 bytes 직접 추출
        buffer = io.BytesIO(generated_image.image_bytes)

        s3_client.upload_fileobj(
            buffer,
            S3_BUCKET,
            filename,
            ExtraArgs={"ContentType": mime_type}
        )

        response_url = f"{CLOUD_FRONT_DOMAIN}/{filename}"

        # 7) 성공 응답 반환
        return JSONResponse({
            "status": "success",
            "image_url": response_url
        })

    except Exception as e:
        print(f"Error in generate_nano: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# --- 3. 유틸리티: Meshy API 통신 세션 (SSL 에러 방지용) ---
def get_meshy_session():
    """
    Meshy API와의 통신을 위한 requests.Session 객체를 생성합니다.
    SSL 연결 오류(SSLEOFError)나 일시적인 네트워크 오류에 대비하여
    재시도(Retry) 로직과 HTTPAdapter를 설정합니다.
    """
    session = requests.Session()
    # 재시도 전략 설정: 최대 5회, 백오프(대기시간) 적용, 특정 에러 코드(5xx) 및 429(Rate Limit) 대응
    retries = Retry(
        total=5,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["HEAD", "GET", "POST"]
    )
    adapter = HTTPAdapter(max_retries=retries)
    # http:// 및 https:// 요청 모두에 어댑터 적용
    session.mount("https://", adapter)
    session.mount("http://", adapter)
    return session

# --- 4. 유틸리티: 이미지 -> Data URI 변환 ---
def file_to_data_uri(image_path: str) -> str:
    """
    로컬 이미지 파일을 읽어 Meshy API가 요구하는 Base64 encoded Data URI 형식으로 변환합니다.
    예: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...
    """
    # 파일 확장자를 기반으로 MIME 타입 추측 (예: image/jpeg, image/png)
    mime_type, _ = mimetypes.guess_type(image_path)
    
    # MIME 타입이 정확히 감지되지 않을 경우 확장자로 수동 할당
    if mime_type not in ("image/jpeg", "image/png"):
        if image_path.lower().endswith(".jpg") or image_path.lower().endswith(".jpeg"):
            mime_type = "image/jpeg"
        elif image_path.lower().endswith(".png"):
            mime_type = "image/png"
        else:
            raise ValueError(f"Unsupported image type: {mime_type}")

    # 파일을 바이너리 읽기 모드로 열어서 Base64 문자열로 인코딩
    with open(image_path, "rb") as f:
        b64 = base64.b64encode(f.read()).decode("utf-8")

    return f"data:{mime_type};base64,{b64}"

# --- 5. 유틸리티: URL에서 이미지 다운로드 후 base64 인코딩 ---
def download_image_as_part(url: str) -> types.Part:
    """URL에서 이미지 다운로드 후 Gemini Part로 반환"""
    response = requests.get(url, timeout=30)
    response.raise_for_status()

    content_type = response.headers.get("Content-Type", "image/png")
    if ";" in content_type:
        content_type = content_type.split(";")[0]

    return types.Part.from_bytes(data=response.content, mime_type=content_type)

# --- 6. API 엔드포인트 ---

# 6.1. Nano Banana 이미지 생성 API (Google Gemini 사용)

class MeshRequest(BaseModel):
    image_path: str

# 5.2. 3D 모델 생성 요청 API (Meshy AI 사용)
@app.post("/api/generate-3d")
async def generate_3d(request: MeshRequest):
    """
    생성된 이미지를 받아 Meshy AI에 3D 모델 생성을 요청합니다.
    이 작업은 비동기로 진행되며 Task ID를 반환합니다.
    """
    image_path = request.image_path
    if not os.path.exists(image_path):
        raise HTTPException(status_code=404, detail="Image file not found")

    try:
        # 1) 이미지를 Data URI로 변환
        data_uri = file_to_data_uri(image_path)
        
        # 2) Meshy 세션 및 헤더 준비
        session = get_meshy_session()
        headers = {"Authorization": f"Bearer {MESHY_API_KEY}"}
        
        # 3) 요청 페이로드 구성
        # should_remesh=True, topology='triangle' 등은 웹/게임 엔진용 최적화를 위한 설정입니다.
        payload = {
            "image_url": data_uri,
            "ai_model": "latest",
            "should_texture": True,
            "enable_pbr": False,
            "should_remesh": True,      # 토폴로지 리메싱 활성화
            "topology": "triangle",     # 삼각형 토폴로지 사용
            "target_polycount": 100000,  # 목표 폴리곤 수 (사용자 설정값: 100,000)
            "symmetry_mode": "auto",    # 대칭 자동 감지
        }
        
        # 4) Meshy API 호출 (작업 등록)
        response = session.post(f"{MESHY_BASE}/image-to-3d", headers=headers, json=payload, timeout=60)
        response.raise_for_status()
        
        # 5) 개발자용 로그 생성 (데이터 URI는 너무 길어서 제외)
        log_info = {
            "request_payload": {k: v for k, v in payload.items() if k != "image_url"}, 
            "response": response.json()
        }
        
        # 6) Task ID 반환
        task_id = response.json().get("result")
        return {"task_id": task_id, "logs": log_info}

    except Exception as e:
        print(f"Error in generate_3d: {e}")
        detail = str(e)
        if isinstance(e, requests.exceptions.SSLError):
            detail = f"SSL Error: {e}"
        raise HTTPException(status_code=500, detail=detail)

# 5.3. 작업 상태 확인 API
@app.get("/api/status/{task_id}")
async def get_status(task_id: str):
    """
    특정 Task ID에 대한 현재 진행 상태(Status)와 진행률(Progress)을 조회합니다.
    프론트엔드에서 주기적으로(Polling) 호출합니다.
    """
    try:
        session = get_meshy_session()
        headers = {"Authorization": f"Bearer {MESHY_API_KEY}"}
        
        # Meshy API에 상태 조회 요청
        response = session.get(f"{MESHY_BASE}/image-to-3d/{task_id}", headers=headers, timeout=30)
        response.raise_for_status()
        
        # 응답 JSON 자체를 반환 (프론트엔드 로그 출력용으로도 사용됨)
        return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
